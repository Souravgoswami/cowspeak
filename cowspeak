#!/usr/bin/ruby -W0
# Written by Sourav Goswami <souravgoswami@protonmail.com>
# The GNU General Public License v3.0
# This program `require` io/console, open-uri, net/http, timeout, socket. They are loaded as needed Search for 'require' in your editior. VERSION Line has to be 5.
VERSION = "Cowspeak version 2.23"

NEW_FEATURES = "1.\tAdded --welcome option (Run cowspeak --help for more)!\n2.\tCowspeak will now be able to read new line characters (\"\\n\")!\n3.\tBugs Fixed.\n4.\tSpeed Improvement."

# Set the path where to look for files and download (--download or -d) the new cowspeak files
PATH = "#{File.dirname(__FILE__)}/cowspeak_files/"
SOURCE_CODE = 'https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak'
MAN_PAGE = 'https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/cowspeak.1.gz'
MAN_PAGE_DIR = "#{PATH}cowspeak.1.gz"

# Uncomment ONLY if ALL of the ABOVE declarations are COMMENTED (except VERSION)
# PATH ||= "/usr/share/cowspeak/"
# SOURCE_CODE ||= 'https://raw.githubusercontent.com/Souravgoswami/cowspeak-deb/master/cowspeak/usr/bin/cowspeak'
# MAN_PAGE ||= 'https://raw.githubusercontent.com/Souravgoswami/cowspeak-deb/master/cowspeak/usr/share/man/man1/cowspeak.1.gz'
# MAN_PAGE_DIR ||= '/usr/share/man/man1/cowspeak.1.gz'

STDIN.sync, STDOUT.sync = true, true

# Errors
ERR_NO_TTY = 128
ERR_FILE_NOT_FOUND = 127
ERR_BAD_FILE = 126
ERR_NO_INTERNET = 64
ERR_SITE_INACCESSIBLE = 63
ERR_DOWNLOAD_UNAVAILABLE = 62
ERR_NO_PERMISSION = 61
ERR_DIAGNOSED = 100

# Check if the output should colourized
coloured = if ARGV.include?('--no-colour') || ARGV.include?('-nc')
	ARGV.delete('--no-colour')
	ARGV.delete('-nc')
	false
else
	true
end

# Check if the output should be blinked
blink = if ARGV.include?('--blink') || ARGV.include?('-b')
	ARGV.delete('--blink')
	ARGV.delete('-b')
	true
else
	false
end

# Check if the colour should be rotated in each line
rotate_colour = if ARGV.include?('--rotate-colour')  || ARGV.include?('-rc')
	ARGV.delete('--rotate_colour')
	ARGV.delete('-rc')
	true
else
	false
end

invert = if ARGV.include?('--invert') || ARGV.include?('-inv')
	ARGV.delete('--invert')
	ARGV.delete('-inv')
	true
else
	false
end

reverse = if ARGV.include?('--reverse') || ARGV.include?('-rev')
	ARGV.delete('--reverse')
	ARGV.delete('-rev')
	true
else
	false
end

display_text = if ARGV.include?('--no-text') || ARGV.include?('-nt')
	ARGV.delete('--no-text')
	ARGV.delete('-nt')
	false
else
	true
end

# Let's make one colour array here so it won't get created everytime in the 'chars' stabby lambda...
available_colours = [196..201, 208..213, 40..45, 28..33, [154, 184, 208, 203, 198, 164, 129, 92], [63, 33, 39, 44, 49, 83, 118],
						[40,41,42,43,211, 210, 209, 208]].map(&:to_a)

available_colours.concat(available_colours.map(&:reverse))

colourize = ->(string) do
	string = string.strip.reverse.concat("\n") if invert

	enum = string.each_line unless reverse
	enum = string.each_line.reverse_each if reverse

	if coloured
		# We are not STDOUT.print in the loop, otherwise the output takes 3x time... temp is for that. Also, don't += rather than concat.
		temp, selected_colour_array = '', available_colours.sample

		STDOUT.print "\e[5m" if blink
		enum.each do |c|
			clength, arr_len = c.length, selected_colour_array.size
			div, index, i = clength/arr_len, 0, 0
			div = 1 if div == 0
			arr_len -= 1

			while i < clength
				index += 1 if (i % div == 0 && index < arr_len) && i > 1
				temp.concat("\e[38;5;#{selected_colour_array[index]}m#{c[i]}")
				i += 1
			end

			selected_colour_array = available_colours.sample if rotate_colour
		end
		STDOUT.print(temp)
	else
		STDOUT.print "\e[5m" if blink
		STDOUT.print enum.to_a.join
	end
	STDOUT.print("\e[0m")
	nil
end

# Determine the terminal size. NOTE: STDIN.winsize instead of STDOUT.winsize will raise Errno::ENOTTY when reading output from stdin redirection.
begin
	require 'io/console'
	Terminal_Width = (STDOUT.winsize[1]/1.4).ceil
rescue Errno::ENOTTY
	colourize.call("Sorry, No terminal found...\n")
	colourize.call("Run this is a proper terminal (gnome-terminal, xfce4-terminal, konsole, terminology, terminator, terminix, xterm, and so on...)\n")
	colourize.call("Also make sure you have ncurses installed (required for calculating number of columns to draw the output)\n")
	colourize.call("Thank you for downloading #{__FILE__.split('/').last}. Run #{__FILE__.split('/').last} --help or #{__FILE__.split('/').last} -h for more details\n")
	exit! ERR_NO_TTY
rescue Exception
	exit!
end

# We have removed the terminal size check. That causes issue on small terminals like termux, asking the user to make the texts smaller.
# In an SSH session that could be catastrophic! Now, you will see broken texts instead of the message in an infinite until loop!!

show_version = false
if ARGV.include?('--version') || ARGV.include?('-v')
	ARGV.delete('--version')
	ARGV.delete('-v')
	show_version = true
end

help = ->(documentation=false) {
rotate_colour = true
colourize.call(
"Hi, my name is cowspeak. I speak a quote on your terminal.

Usage: Run me from the command line without any arguments, and I will show you a fortune.

All the Available arguments:

  --art or -a                   Display a tutorial on adding your own art.
  --blink or -b			Blink the texts.
  --borderh=<ch>/-brh=<ch> 	Horizontal border character.
  --borderv=<ch>/-brv=<ch>	Vertical border character.
  --bubble=<text>/-bbl=<text> 	Specify the character of speech balloons.
  --documentation/-d        	Display the documentation.
  --download/-dl		Download missing files from Github.
  --file=<path>/-f=<path>	Specify the path of your own ASCII art.
  --force-update/-fu		Forcefully update (also see --update)
  --help/-h                 	Display help.
  --invert/-inv			Invert the output (right <- left in English)!
  --manual/-m                	Display a manual. Same as documentation.
  --net=<url>/-n=<url>		Read data from a website (in curl format).
  --no-art/-na			Don't display the animal.
  --no-colour/-nc		Don't colourize the output.
  --no-text/-nt			Don't show any text, show the animal.
  --read=<file>/-r=<file>	Read a file.
  --reverse/-rev		Cowspeak reads upside down!
  --rotate-colour/-rc		Rotate the output colours in each line.
  --show-arts/-sa		Show arts in the default directory.
  --text=<text>/-t=<text>	Display a custom text.
  --version/-v			Display the current #{__FILE__} version.
  --update/-u			Update cowspeak if possible.
  --welcome/-w			Show some system details to the user.\n\n"
)

exit! 0 unless documentation
}

if ARGV.include?('--documentation') || ARGV.include?('-d') || ARGV.include?('--manual') || ARGV.include?('-m')
ARGV.delete('--documentation')
ARGV.delete('-d')
ARGV.delete('--manual')
ARGV.delete('-m')

help.call(documentation=true)
colourize.call(
"
Examples:
	For custom text:
		cowspeak --text='text' / #{__FILE__} -t='text'

	To display your own ASCII art:
		#{__FILE__} --file='path/file.art'

	To display your own art with your text:
		#{__FILE__} --file=directory/file.art --text='your text'

	To read a file from the storage:
		#{__FILE__} --read='path/file.extension' or #{__FILE__} -r='path/file.extension'

	Pipe another program's output to cowspeak (also accepts arguments):
		echo hello | #{__FILE__}
		echo hello | #{__FILE__} --argument -short_argument

	To read from the internet in curl format:
		#{__FILE__} --net=http://www.example.net
		#{__FILE__} --net=http://www.example.net --argument -short_argument

Help:
#{__FILE__} -h or --help for the help message.
#{__FILE__} -d or --documentation or --manual or -m for this documentation.
Creating Custom Art:
You can make your own art. Run #{__FILE__} --art or #{__FILE__} -a for more information.
Update/Download all the files:
If you are missing some files, then please take a moment to download all the files from Github.
To do that, run:
	cowspeak --download or -d
	It will download all the necessary files. This will download less than 400 KiB files from the internet.
	NOTE: This argument will write files to #{PATH} directory.\n\n")

exit! 0
end

if ARGV.include?('--show-arts') || ARGV.include?('-sa')
	Dir.entries(PATH + 'arts').sort.each { |file| puts colourize.call(IO.read(PATH + 'arts/' + file) + "\nPath: #{PATH + 'arts' + file}") unless file == '.' || file == '..' }
	exit! 0
end

# Show a user friendly tutorial on how to add arts
if ARGV.include?('--art') || ARGV.include?('-a')
ARGV.delete('--art')
ARGV.delete('-a')

puts "
You can create your own art. Here's a short introduction on how to do that:
	1. Create an empty document in your computer with 'art' extension (myart.art).
	2. Edit the document and Type your name in the first line. If you copy someone's work, provide the artist's name.
		For example:
			\e[5mCreated by #{ u = '' ; rand(4..8).times do u += rand(97..122).chr end ; u }.\e[0m
	3. The 2nd line is also for crediting. Leave both 1st and 2nd line empty if crediting is not required.
	4. Type your characters and draw your ASCII art.
		Format: What you've done should looks like this:

\e[4mLine\e[0m				\e[4mArt\e[0m

\e[7;34m1\e[0m			\e[5mThanks to #{ u = '' ; rand(4..8).times do u += rand(97..122).chr end ; u } for this art\e[0m
\e[7;34m2\e[0m			\e[5mCollected from example.net\e[0m
\e[7;34m3\e[0m 			\e[5m-------------------------\e[0m
\e[7;34m4\e[0m 			\e[5m=			=\e[0m
\e[7;34m5\e[0m 			\e[5m=    	ASCII Art	=\e[0m
\e[7;34m6\e[0m 			\e[5m=			=\e[0m
\e[7;34m7\e[0m 			\e[5m-------------------------\e[0m

	-> For more examples, look at the other installed files.
	-> You can use other files as example. By default they are located in #{PATH}arts/
	-> Run #{__FILE__} --show-arts or -sa to see all the files
	-> To use your custom art, just run #{__FILE__} --file='your_art.art'
	-> If it is located in another directory then #{__FILE__} --file='directory/your_art.art'

	=> NOTE: If you use someone's art, make sure you have proper permission to copy.
	=> The first 2 lines are for crediting, if you don't have to credit, then leave those lines empty.\n\n"
exit! 0
end

# Take exceptions very very seriously. Handle them very gently.
exception_handle = ->(error='') {
	colourize.call "Uh oh! Sorry, #{__FILE__} has Encountered an Error.\n"
	colourize.call("Select one of the following:
		1. Exit.
		2. Show the usage (#{__FILE__} -h)
		3. Show Error Details.
		4. Save Error Details to a Log File.
		5. Contact Developer.
		-> Choose (Default 1): ")

	case STDIN.gets.to_i
		when 2 then help.call
		when 3 then colourize.call(error.to_s + "\n")
		when 4
			File.open('/tmp/cowspeak-log.txt', 'a+') do |log_file|
				log_file.puts("\n#{Time.new.strftime('Error on %D at %T')} => \n\t#{error}\n#{error.backtrace.join("\n")}\n\n")
				colourize.call('The error has been written to /tmp/cowspeak-log.txt')
			end
		when 5
			colourize.call("Please contact <souravgoswami@protonmail.com>\n")
			colourize.call("Notify us about:\n#{error}\n#{error.backtrace.join("\n")} in #{__FILE__}\n")
	end
	exit! ERR_DIAGNOSED
}

if ARGV.include?('--help') || ARGV.include?('-h')
	ARGV.delete('--help')
	ARGV.delete('-h')
	help.call
end

# Check if force update is enabled
force_update = (ARGV.include?('--force-update') || ARGV.include?('-fu'))
ARGV.delete('--force-update')
ARGV.delete('-fu')

# Check for updates.
if ARGV.include?('--update') || ARGV.include?('-u') || force_update
	require 'net/http'

	ARGV.delete('--update')
	ARGV.delete('-u')

	puts colourize.call('Looking for updates! Please wait a moment...')
	current_version =  VERSION.scan(/\d+.\d+/).join

	begin
		downloaded_data, raw_man_page = Net::HTTP.get(URI(SOURCE_CODE)), Net::HTTP.get(URI(MAN_PAGE))
		puts colourize.call("Current version: #{current_version}")

	rescue SocketError
		puts colourize.call "Can't get version info of cowspeak. Do you have an active internet connection?"
		exit! ERR_NO_INTERNET

	rescue Exception => e
		puts colourize.call 'Something weird happened while trying to contact the server.'
		exception_handle.call(e)
	end

	download_version = downloaded_data.to_s.split("\n").select { |line| line.start_with?('VERSION') }[0].to_s.scan(/\d+.\d+/).to_a[0]
	new_version = download_version.to_f > current_version.to_f

	unless new_version || force_update
		puts colourize.call "#{__FILE__} is up to date! Nothing to do."
	else
		puts colourize.call "A new update is available." if new_version
		puts colourize.call("New Version: #{download_version}\n")

		puts(colourize.call(eval(downloaded_data.to_s.split("\n").select { |line| line.start_with?('NEW_FEATURES') }[0].to_s.split('=')[1].to_s)))
		puts

		puts colourize.call "#{new_version ? 'U' : 'Reu'}pdate to version #{download_version}? (Y/n)"

		exit 0 if STDIN.gets.strip.downcase == 'n'

		begin
			puts colourize.call "Trying to update #{__FILE__}"
			File.write(__FILE__, downloaded_data)
			puts colourize.call "Updated #{__FILE__}"

			ARGV << '--download'

		rescue Errno::EACCES
			puts colourize.call("Permission Denied while trying to overwrite the contents of #{__FILE__}")
			exit! ERR_NO_PERMISSION

		rescue Exception => e
			puts colourize.call "Something wrong happened while trying to overwrite #{__FILE__}"
			exception_handle.call(e)
		end

		puts colourize.call "Update the man page at /usr/share/man/man1/cowspeak.1? (Y/n)"

		unless STDIN.gets.strip.downcase == 'n'
			begin
				puts colourize.call "Trying to update #{MAN_PAGE_DIR}"
				File.write(MAN_PAGE_DIR, raw_man_page)
				puts colourize.call "Man page updated."

			rescue Errno::EACCES
				puts colourize.call("Permission Denied while trying to overwrite the contents of #{__FILE__}")
				exit! ERR_NO_PERMISSION

			rescue Exception => e
				puts colourize.call "Something wrong happened while trying to overwrite #{__FILE__}"
				exception_handle.call(e)
			end
		end
	end
end

if ARGV.include?('--download') || ARGV.include?('-dl')
	ARGV.delete('--download')
	ARGV.delete('-dl')

	colourize.call("Download Data from the internet and save them into #{PATH}?(Y/n): ")
	exit if STDIN.gets.strip.downcase == 'n'

	begin
		require 'net/http'

		unless File.exist?(PATH)
			Dir.mkdir(PATH)
			colourize.call "Created directory #{PATH}\n"
		end

		# The database file originally came from the following source:
		# https://raw.githubusercontent.com/bmc/fortunes/master/fortunes
		# But I like to use the whatever link I used, because it's coming from my github account, and I don't worry about deletion.

		data = Net::HTTP.get(URI('https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/fortunes.data'))
		unless data.include?('404: Not Found')
			File.write(PATH + "fortunes.data", data)
			colourize.call "The fortunes database has been downloaded and installed to #{PATH}fortunes.\n"

			unless File.exist?(PATH + "arts")
				Dir.mkdir(PATH + "arts")
				colourize.call "Created directory #{PATH}arts/\n"
			end

			puts colourize.call "Downloading art files...\n"

			# Install the art files...
			uris = %w(
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/cow.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/dolphin.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/killer_squirrels.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/penguin.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/spider.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/squirrels.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/cat.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/deer.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/dog.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/eagle.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/hippo.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/scorpion.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/camel.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/turtle.art
				https://raw.githubusercontent.com/Souravgoswami/cowspeak/master/cowspeak_files/arts/mouse.art
				)

			write_to = %w(cow dolphin killer_squirrels penguin spider squirrels cat deer dog eagle hippo scorpion camel turtle mouse)

			raise RuntimeError, "Dear Developer, the uris has to match write_to size, line: #{__LINE__}" unless write_to.size == uris.size

			uris.size.times do |index|
				File.write("#{PATH + "arts/" + write_to[index]}.art", Net::HTTP.get(URI(uris[index])))

				puts colourize.call "Successfully installed an art file in #{PATH}arts/"
				puts colourize.call "#{IO.read(PATH + 'arts/' + write_to[index] + '.art')}\n"
			end

			colourize.call "All Done!\n"
			colourize.call "To see the available arts, type: #{__FILE__} --show-arts or -sa\n"
			colourize.call "Here's a fortune for you!\n"
		else
			colourize.call "Sorry for the inconvenience. Something went terribly wrong (can't access one of the file).\n"
			colourize.call "If the problem persists, contact: souravgoswami@protonmail.com.\n"
			exit! ERR_DOWNLOAD_UNAVAILABLE
		end

	rescue SocketError
		colourize.call "Do you have an internet connection?\n"
		colourize.call "1. Exit.\n2. Retry.\nDefault: 1 (Exit).\n"
		retry if STDIN.gets.to_i == 2
		exit! ERR_NO_INTERNET

	rescue Errno::EACCES
		colourize.call "Requires root privilege to write to #{PATH} directory. Please run #{__FILE__} with proper permission.\n"
		exit! ERR_NO_PERMISSION

	rescue Exception => e
		exception_handle.call(e)
	end
end

show_art = true
if ARGV.include?('--no-art') || ARGV.include?('-na')
	ARGV.delete('--no-art')
	ARGV.delete('-na')
	show_art = false
end

borderh = ARGV.select { |a| a.start_with?('--borderh=') || a.start_with?('-brh=') }[-1].to_s
borderh = borderh.empty? ? '=' : borderh.split('=')[1].to_s.chars.sample.to_s

borderv = ARGV.select { |a| a.start_with?('--borderv=') || a.start_with?('-brv=')  }[-1].to_s
borderv = borderv.empty? ? '|' : borderv.split('=')[1].to_s.chars.sample.to_s

bubble = ARGV.select { |a| a.start_with?('--bubble=') || a.start_with?('-bbl=') }[-1].to_s
if bubble
	bubble = bubble.split('=')[1]
	bubble = 'o' unless bubble
end

begin
	file = ARGV.select { |a| a.start_with?('--file') || a.start_with?('-f') }
	file.each do |arg| ARGV.delete(arg) end

	if file[-1]
		file = if file[-1].split('=')[1] then file[-1].split('=')[1]
		else PATH + "arts/#{%w(cow squirrels killer_squirrels cat deer dog mouse camel).sample}.art"
		end
	else
			file = PATH + "arts/#{%w(cow squirrels killer_squirrels cat deer dog mouse camel turtle).sample}.art"
	end

	unless File.file?(file)
		colourize.call "Looks like the art file doesn't exist.\n"
		colourize.call "Type #{__FILE__} --download or #{__FILE__} -d to download all the necessary files.\n"
		colourize.call "Type #{__FILE__} --show-arts or #{__FILE__} -sa to see available arts in the default directory...\n"
		colourize.call "Type #{__FILE__} --help or #{__FILE__} -h for help.\n"
		colourize.call "Type #{__FILE__} --art or #{__FILE__} -a for help regarding art.\n"
		file = PATH + "arts/#{%w(cow squirrels killer_squirrels cat deer dog mouse camel).sample}.art"

		unless File.readable?(file)
			colourize.call("The default files at location #{PATH + 'arts/'} doesn't exist\n")
			colourize.call("Please run #{__FILE__} -dl to download all the necessary files at #{PATH}\n")
			exit! ERR_FILE_NOT_FOUND
		end
	end

	text = ''
	pipe = false

	# Check if pipe and output is redicred from another program, waste no time on gets if not
	begin
		require 'timeout'
		Timeout.timeout 0.000_000_000_000_1 do pipe = STDIN.gets end
	rescue Interrupt
		exit! 0
	rescue Exception
	end

	# if pipe is passed, read it until it ends. Else, read fortunes.
	if pipe
		text.concat(pipe)
		loop do
			break unless val = STDIN.gets
			text.concat(val)
		end
		text.chomp!

	elsif show_version
		text = VERSION

	elsif ARGV.include?('--welcome') || ARGV.include?('-w')
		require 'socket'
		user, logname, hostname, time = ENV['USER'].split.map(&:capitalize).join, ENV['LOGNAME'], Socket.gethostname, Time.new.strftime('%B %d, %A, %H:%M:%S')
		files = Dir.entries(Dir.pwd)[2..-1].count

		os = if File.readable?('/etc/os-release')
			"#{IO.readlines('/etc/os-release')[0].split('=')[1].strip.scan(/[a-z0-9A-Z\s]/).join} (#{RUBY_PLATFORM})"
		elsif File.readable?('/etc/lsb-release')
			"#{IO.readlines('/etc/os-release')[0].split('=')[1].strip.scan(/[a-z0-9A-Z\s]/).join} (#{RUBY_PLATFORM})"
		else
			'Cannot obtain OS details'
		end

		uptime = File.readable?('/proc/uptime') ? IO.read('/proc/uptime').split[0].to_i : 0
		up = "#{(uptime/3600)} " + ((uptime/3600) != 1 ? 'hours' : 'hour') + ', '
		up += "#{(uptime % 3600 / 60)} " + ((uptime % 3600 / 60) != 1 ? 'minutes' : ' minute') + ', '
		up += "#{(uptime % 60)} " + ((uptime % 60) != 1 ? 'seconds' : 'second')

		session = ENV['DESKTOP_SESSION']
		session = session ? "Desktop Session: #{session}\n" : ''

		text = "Welcome #{user}!\nLog Name: #{logname}\nHost Name: #{hostname}\n#{session}OS: #{os}\nUptime: #{up}\nShell: #{ENV['SHELL']}\nPWD: #{Dir.pwd} (#{files} items)\nTime: #{time}"

	elsif text.empty?
		text = ARGV.select { |t| t.start_with?('--text=') || t.start_with?('-t=') }
		text.each { |arg| ARGV.delete(arg) }

		text = text[-1].split('=')[1] unless text.empty?

		if text.nil? || text.empty?
			if File.readable?(PATH + "fortunes.data")
				text = IO.read(PATH + "fortunes.data").split("\n%\n").sample.gsub("\n", ' ')
			else
				text = ("The fortune file doesn't exist.
						Please run #{__FILE__} -dl to download the files to #{PATH}")
			end
		end

		read = ARGV.select { |r| r.start_with?('--read=') || r.start_with?('-r=') }
		read.each do |arg| ARGV.delete(arg) end

		unless read.empty?
			f = read[-1].split('=')[1].to_s
			text = IO.read(f).chomp if File.readable?(f)
		end

		net = ARGV.select { |n| n.start_with?('--net=') || n.start_with?('-n=') }
		net.each { |arg| ARGV.delete(arg) }

		unless net.empty?
			uri = net[-1].split('=')[1].to_s
			begin
				show_art = false
				require 'net/http'
				require 'open-uri'
				text = open(uri).read + "\n"

			rescue SocketError
				colourize.call "Failed  to read the URL. Do you have an active internet connection?\n"
				exit! ERR_NO_INTERNET

			rescue SystemExit, Interrupt
				show_art = true
				print "\n\n"

			rescue Exception
				colourize.call "Sorry an error occurred while trying to open #{uri}\n"
				colourize.call "Failed to open the URL. Have you mentioned the protocol?\n"
				colourize.call "Example:\n\thttp://www.example.net\n"
				exit! ERR_SITE_INACCESSIBLE
			end
		end
	end

	corners = (borderh.empty? || borderv.empty?) ? [' ', ' ', ' ', ' '] : [' //', '\\\\',  ' \\\\',  '//']
	all_chars = ''

	if show_art && display_text
		text = ' ' + text.gsub("\t", ' ')	# gsub is faster than tr, and gsub won't raise 'invalid byte sequence' ArgumentError for weird characters.

		count, init, init_length = 0, borderh * Terminal_Width, Terminal_Width - 1
		all_chars.concat("#{corners[0]}#{init}#{corners[1]}\n #{borderv}")

		text.each_char do |c|
			unless (count >= init_length - 8 && c == " ") || count >= init_length || c == "\n"
				all_chars.concat(c)
			else
				all_chars.concat((c == "\n" ? ' ' : c) + " " * (init_length - count + 2) + borderv + "\n #{borderv} ")
				count = 0
			end

			count += 1
		end
		all_chars.concat(" " * (init_length - count + 3) + borderv)

		animal = IO.readlines(file)[2..-1]

		unless animal
			puts colourize.call "The file #{File.zero?(file) ? 'looks empty' : 'is not properly formatted' }. Run cowspeak --art to get help regarding art."
			exit! ERR_BAD_FILE
		end

		max_length = animal.map(&:length).max/2

		colourize.call(all_chars + "\n" + corners[2] + init + corners[3] + "\n" +
			" " * max_length + bubble * 3 + "\n " + ' ' * max_length + bubble * 2 + "\n" + ' ' * max_length +  bubble + "\n" + animal.join)

	elsif show_art then colourize.call(IO.readlines(file)[2..-1].join)
	elsif display_text then colourize.call(text)
	end

rescue SystemExit, Interrupt
	printf "\n\n"
	puts colourize.call('Exiting...')
	exit! 0

rescue Exception => e
	exception_handle.call(e)
end
